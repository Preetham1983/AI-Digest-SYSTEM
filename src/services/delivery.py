import aiosmtplib
import markdown
from email.message import EmailMessage
from src.config import settings
from src.services.logger import logger

async def send_email(subject: str, markdown_content: str):
    if not settings.EMAIL_FROM or not settings.EMAIL_TO or not settings.EMAIL_PASSWORD:
        logger.warning("Email configuration missing. Skipping email delivery.")
        return

    message = EmailMessage()
    message["From"] = settings.EMAIL_FROM
    message["To"] = settings.EMAIL_TO
    message["Subject"] = subject

    # Convert Markdown to HTML
    html_body = markdown.markdown(markdown_content)
    
    # Wrap in simple template
    full_html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }}
            h2 {{ color: #2980b9; margin-top: 30px; border-bottom: 1px solid #eee; padding-bottom: 5px; }}
            h3 {{ color: #16a085; margin-top: 20px; }}
            a {{ color: #3498db; text-decoration: none; font-weight: bold; }}
            blockquote {{ border-left: 4px solid #ddd; padding-left: 15px; color: #555; background: #f9f9f9; padding: 10px; }}
            hr {{ border: 0; height: 1px; background: #eee; margin: 30px 0; }}
            .footer {{ font-size: 0.8em; color: #7f8c8d; text-align: center; }}
        </style>
    </head>
    <body>
        <div class="content">
            {html_body}
        </div>
        <hr>
        <div class="footer">
            <p>Generated by AI Intelligence Digest</p>
        </div>
    </body>
    </html>
    """
    
    message.set_content(markdown_content) # Fallback plain text
    message.add_alternative(full_html, subtype='html')

    try:
        # Get custom recipients from DB
        from src.services.database import db
        # We need to get the preference synchronously or ensure we are in an async context.
        # Since this function is async, we can call the async db method.
        # Note: We create a new connection or use the existing db instance.
        
        custom_emails_str = await db.get_preference("DELIVERY_EMAIL_CUSTOM_RECIPIENTS", "")
        custom_emails = [e.strip() for e in custom_emails_str.split(',') if e.strip()]
        
        # Determine all recipients: Primary + Custom
        recipients = []
        if settings.EMAIL_TO:
            recipients.append(settings.EMAIL_TO)
        
        for ce in custom_emails:
            if ce not in recipients: # Avoid duplicates
                recipients.append(ce)
        
        if not recipients:
            logger.warning("No email recipients configured.")
            return

        logger.info(f"Preparing to send email to {len(recipients)} recipients...")

        # SMTP Connection context
        # Use implicit SSL on port 465 (usually more reliable than STARTTLS on 587)
        use_tls = False
        start_tls = True
        
        if settings.EMAIL_SMTP_PORT == 465:
            use_tls = True
            start_tls = False

        # We'll use a single connection for efficiency if possible, 
        # but for simplicity and robustness against individual failures, we can loop.
        # Let's try sending individually to avoid exposing all recipients in To/CC fields 
        # and to handle per-user failures gracefully.
        
        for recipient in recipients:
            try:
                # Update To field for each message
                message.replace_header("To", recipient)
                
                logger.info(f"Sending email to {recipient}...")
                await aiosmtplib.send(
                    message,
                    hostname=settings.EMAIL_SMTP_HOST,
                    port=settings.EMAIL_SMTP_PORT,
                    username=settings.EMAIL_FROM,
                    password=settings.EMAIL_PASSWORD,
                    use_tls=use_tls,
                    start_tls=start_tls,
                    timeout=settings.EMAIL_TIMEOUT
                )
                logger.info(f"Email sent successfully to {recipient}.")
            except Exception as e:
                logger.error(f"Failed to send email to {recipient}: {e}")

    except Exception as e:
        logger.error(f"General email failure: {e}")

import httpx

import re

async def send_telegram(markdown_content: str):
    if not settings.TELEGRAM_BOT_TOKEN or not settings.TELEGRAM_CHAT_ID:
        logger.warning("Telegram configuration missing. Skipping Telegram delivery.")
        return

    logger.info(f"Sending Telegram message to {settings.TELEGRAM_CHAT_ID}...")
    
    # Format for Telegram HTML
    html_content = format_for_telegram(markdown_content)
    
    # Telegram limit is 4096 chars.
    # We will split by double newline to avoid breaking HTML tags as much as possible, 
    # though ideally we would parse. Given the structure is mostly blocks, this is decent.
    
    chunks = []
    current_chunk = ""
    
    # Split by newline logic, but working on the HTML content
    # Note: simple splitting might break open tags (like <b>...</b>). 
    # For a robust solution without a parser, we assume standard digest structure 
    # doesn't have extremely long formatted blocks.
    
    lines = html_content.split('\n')
    for line in lines:
        if len(current_chunk) + len(line) + 1 > 4000:
            chunks.append(current_chunk)
            current_chunk = ""
        current_chunk += line + "\n"
    if current_chunk:
        chunks.append(current_chunk)

    async with httpx.AsyncClient() as client:
        for i, chunk in enumerate(chunks):
            try:
                url = f"https://api.telegram.org/bot{settings.TELEGRAM_BOT_TOKEN}/sendMessage"
                payload = {
                    "chat_id": settings.TELEGRAM_CHAT_ID,
                    "text": chunk,
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                resp = await client.post(url, json=payload, timeout=10.0)
                if resp.status_code != 200:
                    logger.error(f"Telegram send failed: {resp.text}")
                else:
                    logger.info(f"Telegram chunk {i+1}/{len(chunks)} sent.")
            except Exception as e:
                logger.error(f"Telegram transport failed: {e}")

def format_for_telegram(text: str) -> str:
    """
    Convert Markdown to a subset of HTML supported by Telegram.
    """
    # Use the existing markdown library to get basic HTML
    html = markdown.markdown(text)
    
    # Simple replacements to map standard HTML to Telegram supported tags
    # Headers h1-h6 -> <b>...</b> (and maybe newline)
    html = re.sub(r'<h[1-6]>(.*?)</h[1-6]>', r'<b>\1</b>\n', html)
    
    # Paragraphs <p> -> just content + newline
    html = html.replace('<p>', '').replace('</p>', '\n')
    
    # Lists
    html = html.replace('<ul>', '').replace('</ul>', '')
    html = html.replace('<li>', 'â€¢ ').replace('</li>', '\n')
    
    # Strong/Em to b/i (Telegram supports strong/em but b/i consumes fewer chars)
    html = html.replace('<strong>', '<b>').replace('</strong>', '</b>')
    html = html.replace('<em>', '<i>').replace('</em>', '</i>')
    
    # Blockquotes
    html = html.replace('<blockquote>', '<i>').replace('</blockquote>', '</i>')
    
    # Horizontal Rules
    html = re.sub(r'<hr\s*/?>', '-------------------\n', html)
    
    return html
