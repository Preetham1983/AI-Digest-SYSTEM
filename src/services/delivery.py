import aiosmtplib
import markdown
from email.message import EmailMessage
from src.config import settings
from src.services.logger import logger

async def send_email(subject: str, markdown_content: str):
    """Send email to primary recipient and all custom recipients using a single SMTP connection."""
    if not settings.EMAIL_FROM or not settings.EMAIL_TO or not settings.EMAIL_PASSWORD:
        logger.warning("Email configuration missing. Skipping email delivery.")
        return

    # Convert Markdown to HTML
    html_body = markdown.markdown(markdown_content)
    
    # Wrap in simple template
    full_html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }}
            h2 {{ color: #2980b9; margin-top: 30px; border-bottom: 1px solid #eee; padding-bottom: 5px; }}
            h3 {{ color: #16a085; margin-top: 20px; }}
            a {{ color: #3498db; text-decoration: none; font-weight: bold; }}
            blockquote {{ border-left: 4px solid #ddd; padding-left: 15px; color: #555; background: #f9f9f9; padding: 10px; }}
            hr {{ border: 0; height: 1px; background: #eee; margin: 30px 0; }}
            .footer {{ font-size: 0.8em; color: #7f8c8d; text-align: center; }}
        </style>
    </head>
    <body>
        <div class="content">
            {html_body}
        </div>
        <hr>
        <div class="footer">
            <p>Generated by AI Intelligence Digest</p>
        </div>
    </body>
    </html>
    """

    try:
        # Get custom recipients from DB
        from src.services.database import db
        
        custom_emails_str = await db.get_preference("DELIVERY_EMAIL_CUSTOM_RECIPIENTS", "")
        custom_emails = [e.strip() for e in custom_emails_str.split(',') if e.strip()]
        
        # Determine all recipients: Primary + Custom
        recipients = []
        if settings.EMAIL_TO:
            recipients.append(settings.EMAIL_TO)
        
        for ce in custom_emails:
            if ce not in recipients:  # Avoid duplicates
                recipients.append(ce)
        
        if not recipients:
            logger.warning("No email recipients configured.")
            return

        logger.info(f"Preparing to send email to {len(recipients)} recipients...")

        # Determine TLS settings based on port
        use_tls = settings.EMAIL_SMTP_PORT == 465
        start_tls = not use_tls  # Use STARTTLS for port 587

        # Use a SINGLE connection for ALL recipients (optimized)
        try:
            smtp = aiosmtplib.SMTP(
                hostname=settings.EMAIL_SMTP_HOST,
                port=settings.EMAIL_SMTP_PORT,
                use_tls=use_tls,
                start_tls=start_tls,
                timeout=settings.EMAIL_TIMEOUT
            )
            
            await smtp.connect()
            await smtp.login(settings.EMAIL_FROM, settings.EMAIL_PASSWORD)
            
            for recipient in recipients:
                try:
                    # Create a fresh message for each recipient
                    message = EmailMessage()
                    message["From"] = settings.EMAIL_FROM
                    message["To"] = recipient
                    message["Subject"] = subject
                    message.set_content(markdown_content)  # Fallback plain text
                    message.add_alternative(full_html, subtype='html')
                    
                    await smtp.send_message(message)
                    logger.info(f"✅ Email sent to {recipient}")
                except Exception as e:
                    logger.error(f"Failed to send email to {recipient}: {e}")
            
            await smtp.quit()
            logger.info(f"Email delivery complete ({len(recipients)} recipients).")
            
        except Exception as e:
            logger.error(f"SMTP connection failed: {e}")

    except Exception as e:
        logger.error(f"General email failure: {e}")

import httpx

import re

async def send_telegram(markdown_content: str):
    if not settings.TELEGRAM_BOT_TOKEN or not settings.TELEGRAM_CHAT_ID:
        logger.warning("Telegram configuration missing. Skipping Telegram delivery.")
        return

    logger.info(f"Sending Telegram message to {settings.TELEGRAM_CHAT_ID}...")
    
    # Format for Telegram HTML
    html_content = format_for_telegram(markdown_content)
    
    # Telegram limit is 4096 chars.
    # We will split by double newline to avoid breaking HTML tags as much as possible, 
    # though ideally we would parse. Given the structure is mostly blocks, this is decent.
    
    chunks = []
    current_chunk = ""
    
    # Split by newline logic, but working on the HTML content
    # Note: simple splitting might break open tags (like <b>...</b>). 
    # For a robust solution without a parser, we assume standard digest structure 
    # doesn't have extremely long formatted blocks.
    
    lines = html_content.split('\n')
    for line in lines:
        if len(current_chunk) + len(line) + 1 > settings.TELEGRAM_CHUNK_SIZE:
            chunks.append(current_chunk)
            current_chunk = ""
        current_chunk += line + "\n"
    if current_chunk:
        chunks.append(current_chunk)

    async with httpx.AsyncClient() as client:
        for i, chunk in enumerate(chunks):
            try:
                url = f"https://api.telegram.org/bot{settings.TELEGRAM_BOT_TOKEN}/sendMessage"
                payload = {
                    "chat_id": settings.TELEGRAM_CHAT_ID,
                    "text": chunk,
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                resp = await client.post(url, json=payload, timeout=10.0)
                if resp.status_code != 200:
                    logger.error(f"Telegram send failed: {resp.text}")
                else:
                    logger.info(f"Telegram chunk {i+1}/{len(chunks)} sent.")
            except Exception as e:
                logger.error(f"Telegram transport failed: {e}")

def format_for_telegram(text: str) -> str:
    """
    Convert Markdown to a subset of HTML supported by Telegram.
    """
    # Use the existing markdown library to get basic HTML
    html = markdown.markdown(text)
    
    # Simple replacements to map standard HTML to Telegram supported tags
    # Headers h1-h6 -> <b>...</b> (and maybe newline)
    html = re.sub(r'<h[1-6]>(.*?)</h[1-6]>', r'<b>\1</b>\n', html)
    
    # Paragraphs <p> -> just content + newline
    html = html.replace('<p>', '').replace('</p>', '\n')
    
    # Lists
    html = html.replace('<ul>', '').replace('</ul>', '')
    html = html.replace('<li>', '• ').replace('</li>', '\n')
    
    # Strong/Em to b/i (Telegram supports strong/em but b/i consumes fewer chars)
    html = html.replace('<strong>', '<b>').replace('</strong>', '</b>')
    html = html.replace('<em>', '<i>').replace('</em>', '</i>')
    
    # Blockquotes
    html = html.replace('<blockquote>', '<i>').replace('</blockquote>', '</i>')
    
    # Horizontal Rules
    html = re.sub(r'<hr\s*/?>', '-------------------\n', html)
    
    return html
